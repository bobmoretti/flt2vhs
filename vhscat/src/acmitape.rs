// generated by rust-bindgen 0.57.0, hacked down manually

use std::io;
use std::io::prelude::*;

use anyhow::*;
use serde_derive::*;

use crate::read_primitives::*;

#[derive(Debug, Default, Copy, Clone, Serialize)]
pub struct TapeHeader {
    pub file_id: [u8; 4],
    pub file_size: u32,
    pub entity_count: i32,
    pub feature_count: i32,
    pub entity_block_offset: u32,
    pub feature_block_offset: u32,
    pub timeline_count: i32,
    pub timeline_block_offset: u32,
    pub first_entity_event_offset: u32,
    pub first_general_event_offset: u32,
    pub first_event_trailer_offset: u32,
    pub first_text_event_offset: u32,
    pub first_feature_event_offset: u32,
    pub event_count: i32,
    pub entity_event_count: i32,
    pub text_event_count: i32,
    pub feature_event_count: i32,
    pub start_tim: f32,
    pub tot_play_time: f32,
    pub tod_offset: f32,
}

impl TapeHeader {
    pub fn read<R: Read>(r: &mut R) -> Result<Self> {
        let mut file_id: [u8; 4] = [0; 4];
        r.read_exact(&mut file_id)?;

        let file_size = read_u32(r)?;
        let entity_count = read_i32(r)?;
        let feature_count = read_i32(r)?;
        let entity_block_offset = read_u32(r)?;
        let feature_block_offset = read_u32(r)?;
        let timeline_count = read_i32(r)?;
        let timeline_block_offset = read_u32(r)?;
        let first_entity_event_offset = read_u32(r)?;
        let first_general_event_offset = read_u32(r)?;
        let first_event_trailer_offset = read_u32(r)?;
        let first_text_event_offset = read_u32(r)?;
        let first_feature_event_offset = read_u32(r)?;
        let event_count = read_i32(r)?;
        let entity_event_count = read_i32(r)?;
        let text_event_count = read_i32(r)?;
        let feature_event_count = read_i32(r)?;
        let start_tim = read_f32(r)?;
        let tot_play_time = read_f32(r)?;
        let tod_offset = read_f32(r)?;

        Ok(Self {
            file_id,
            file_size,
            entity_count,
            feature_count,
            entity_block_offset,
            feature_block_offset,
            timeline_count,
            timeline_block_offset,
            first_entity_event_offset,
            first_general_event_offset,
            first_event_trailer_offset,
            first_text_event_offset,
            first_feature_event_offset,
            event_count,
            entity_event_count,
            text_event_count,
            feature_event_count,
            start_tim,
            tot_play_time,
            tod_offset,
        })
    }
}

#[derive(Debug, Copy, Clone, Serialize)]
pub struct Entity {
    pub uid: i32,
    pub kind: i32,
    pub count: i32,
    pub flags: u32,
    pub lead_index: i32,
    pub slot: i32,
    pub special_flags: u32,
    pub first_position_data_offset: u32,
    pub first_event_data_offset: u32,
}

impl Entity {
    pub fn read<R: Read>(r: &mut R) -> Result<Self> {
        let uid = read_i32(r)?;
        let kind = read_i32(r)?;
        let count = read_i32(r)?;
        let flags = read_u32(r)?;
        let lead_index = read_i32(r)?;
        let slot = read_i32(r)?;
        let special_flags = read_u32(r)?;
        let first_position_data_offset = read_u32(r)?;
        let first_event_data_offset = read_u32(r)?;

        Ok(Self {
            uid,
            kind,
            count,
            flags,
            lead_index,
            slot,
            special_flags,
            first_position_data_offset,
            first_event_data_offset,
        })
    }
}

#[derive(Debug, Copy, Clone, Serialize)]
pub struct TimelineEntry {
    pub time: f32,
    pub payload: TimelineEntryPayload,
    pub next_position_update_offset: u32,
    pub previous_position_update_offset: u32,
}

impl TimelineEntry {
    pub fn read<R: Read + Seek>(r: &mut R) -> Result<Self> {
        let time = read_f32(r)?;
        let payload = match read_u8(r)? {
            0 => TimelineEntryPayload::Pos(Position::read(r)?),
            1 => TimelineEntryPayload::Switch(Switch::read(r)?),
            2 => TimelineEntryPayload::DOF(DOF::read(r)?),
            wut => bail!("Invalid timeline entry type: {}", wut),
        };
        let next_position_update_offset = read_u32(r)?;
        let previous_position_update_offset = read_u32(r)?;

        Ok(Self {
            time,
            payload,
            next_position_update_offset,
            previous_position_update_offset,
        })
    }
}

#[derive(Debug, Copy, Clone, Serialize)]
pub enum TimelineEntryPayload {
    Pos(Position),
    Switch(Switch),
    DOF(DOF),
}

#[derive(Debug, Copy, Clone, Serialize)]
pub struct Position {
    pub x: f32,
    pub y: f32,
    pub z: f32,
    pub pitch: f32,
    pub roll: f32,
    pub yaw: f32,
    pub radar_target: i32,
}

impl Position {
    pub fn read<R: Read>(r: &mut R) -> Result<Self> {
        let x = read_f32(r)?;
        let y = read_f32(r)?;
        let z = read_f32(r)?;
        let pitch = read_f32(r)?;
        let roll = read_f32(r)?;
        let yaw = read_f32(r)?;
        let radar_target = read_i32(r)?;

        Ok(Self {
            x,
            y,
            z,
            pitch,
            roll,
            yaw,
            radar_target,
        })
    }
}

#[derive(Debug, Copy, Clone, Serialize)]
pub struct Switch {
    pub switch_index: i32,
    pub switch_value: i32,
    pub previous_switch_value: i32,
}

impl Switch {
    pub fn read<R: Read + Seek>(r: &mut R) -> Result<Self> {
        let switch_index = read_i32(r)?;
        let switch_value = read_i32(r)?;
        let previous_switch_value = read_i32(r)?;

        // The other union values have another four 4-byte values
        r.seek(io::SeekFrom::Current(16))?;

        Ok(Self {
            switch_index,
            switch_value,
            previous_switch_value,
        })
    }
}

#[derive(Debug, Copy, Clone, Serialize)]
pub struct DOF {
    pub dof_index: i32,
    pub dof_value: f32,
    pub previous_dof_value: f32,
}

impl DOF {
    pub fn read<R: Read + Seek>(r: &mut R) -> Result<Self> {
        let dof_index = read_i32(r)?;
        let dof_value = read_f32(r)?;
        let previous_dof_value = read_f32(r)?;

        // The other union values have another four 4-byte values
        r.seek(io::SeekFrom::Current(16))?;

        Ok(Self {
            dof_index,
            dof_value,
            previous_dof_value,
        })
    }
}

#[derive(Copy, Clone)]
pub struct RawPosition {
    pub kind: i32,
    pub uid: i32,
    pub flags: i32,
    pub lead_index: i32,
    pub slot: i32,
    pub special_flags: i32,
}

#[derive(Debug, Copy, Clone)]
pub struct EventHeader {
    pub event_type: u8,
    pub index: i32,
    pub time: f32,
    pub time_end: f32,
    pub kind: i32,
    pub user: i32,
    pub flags: i32,
    pub scale: f32,
    pub x: f32,
    pub y: f32,
    pub z: f32,
    pub dx: f32,
    pub dy: f32,
    pub dz: f32,
    pub roll: f32,
    pub pitch: f32,
    pub yaw: f32,
}

#[derive(Debug, Copy, Clone)]
pub struct EventTrailer {
    pub time_end: f32,
    pub index: i32,
}

#[derive(Debug, Copy, Clone)]
pub struct FeatEvent {
    pub time: f32,
    pub index: i32,
    pub new_status: i32,
    pub prevous_status: i32,
}

#[derive(Debug, Copy, Clone)]
pub struct FeatEventImport {
    pub unique_id: i32,
    pub data: FeatEvent,
}

#[derive(Debug, Copy, Clone)]
pub struct EntityReadHead {
    pub position_offset: u32,
    pub event_offset: u32,
}

#[derive(Debug, Copy, Clone)]
pub struct CallRec {
    pub label: [u8; 16usize],
    pub team_color: i32,
}
